# Описание протокола
_Версия: 1, черновая_

Ответы сервера - в формате JSON. При успешной обработке запроса поле **error** содержит значение **null**. При возникновении ошибки в поле **error** содержится объект с кодом ошибки и его текстовым описанием. Кроме того, код ошибки возвращается в самом HTTP ответе. Если поле **error** не равно **null**, то поля **response** может не существовать, иначе оно должно обязательно присутствовать.

Коды ошибок:

| Внутренний код | Описание                        |
|----------------|---------------------------------|
| 0              | Ошибка авторизации              |
| 1              | Ошибка регистрации              |
| 2              | Пустой ответ сервера            |
| 3              | Ошибка в параметрах запроса     |
| 4              | Нет прав выполнить это действие |
| 5              | Внутренняя ошибка сервера       |

## Регистрация
#### Запрос на регистрацию
```
POST /api/v1/auth/signup
```
Параметры:
  - **username** - имя пользователя
  - **email** - email
  - **password** - пароль

#### Ответ сервера
Регистрация прошла успешно:
```js
{
    error: null,
    response: {
        user: {
            username: "ivan333",
            email: "ivan@gmail.com",
            global_rating: 0
        }
    }
}
```

Пример ошибки при регистрации:
```js
{
    error: {
        code: 1,
        description: "Пользователь с таким именем уже существует"
    }
}
```

## Авторизация
#### Запрос на авторизацию
```
POST /api/v1/auth/signin
```
Параметры:
  - **username** - имя пользователя
  - **password** - пароль

#### Ответ сервера
Авторизация прошла успешно:
```js
{
    error: null,
    response: {
        user: {
            username: "ivan333",
            email: "ivan@gmail.com",
            global_rating: 0
        }
    }
}
```

Пример ошибки при авторизации:
```js
{
    error: {
        code: 0,
        description: "Неправильная пара логин/пароль"
    }
}
```
## Пользователь
#### Получение информации о пользователе
```
GET /api/v1/user/
```

#### Ответ сервера
```js
{
    error: null,
    response: {
        user: {
            username: "ivan333",
            email: "ivan@gmail.com",
            global_rating: 0
        }
    }
}
```

## Игра
Для начала игры, требуется установить соединение с сервером по протоколу WebSocket:
```
ws://servername:port/
```
Клиент может быть отключен от сервера с указанием причины:
  - Код закрытия **0**. Окончание игры.
  - Код закрытия **1**. Клиент не авторизован (не имеет cookie с идентификатором активной сессии)
  - Код закрытия **2**. Нет свободных комнат.
  - Код закрытия **3**. Клиент отключен из-за долгого бездействия.

Общение происходит в формате BSON. Для работы с этим форматом на клиенте можно использовать [js-bson](https://github.com/schteppe/js-bson). Сначала требуется выставить правильный тип данных для соединения:

```js
ws.binaryType = "arraybuffer";
```

Затем, чтобы отправить данные необходимо сделать следующее:
```js
ws.send(BSON.serialize(object));
```

И для приема данных:
```js
ws.onmessage = function (e) {
    var object = BSON.deserialize(e.data);
    ...
};
```

Далее для обозначения сериализованных в BSON JSON объектов, с помощью которых общаются сервер и клиент, будет использоваться термин _пакет_. У каждого типа пакетов есть свой код, который однозначно его идентифицирует.

#### Перед началом

Перед тем как начнется игровой процесс, игроки собираются в комнате. При подключении нового игрока к серверу, его прикрепляют к свободной комнате. После прикрепления к комнате, сервер передает клиенту следующий пакет:

```js
{
    code: 0,
    roomId: 388,
    players: [
        {
            player_id: 399,
            username: "ivan333",
            global_rating: 0,
            color: "#abcdef",
            isReady: false
        }
    ]
}
```

До начала игры, каждый из игроков в комнате должен нажать на кнопку готовности. Если по истечению 20 секунд после нажатия кнопки готовности последнего игрока кто-либо не является готовым, то он должен быть отключен сервером.

После нажатия на кнопку готовности, клиент должен отправить:
```js
{
    code: 1,
    ready: true
}
```

Этот пакет затем рассылается всем игрокам в текущей комнате в следующем виде:
```js
{
    code: 2,
    ready: true,
    player_id: 399
}
```

#### Начало игры
После готовности всех игроков, сервер рассылает всем изначальные позиции змеек:
```js
{
    code: 3,
    players: [
        {
            player_id: 399,
            username: "ivan333",
            rating: 0,
            color: "#abcdef",
            snake: {
                head: {
                    position: {
                        x: 567,
                        y: 124
                    },
                    speed: {
                        x: 8.66666666,
                        y: 4.33333333
                    }
                },
                parts: []
            }
        }
    ]
}
```

Затем ровно через 3 секунды, должна начаться игра.

#### Процесс игры
Во время игры каждый клиент должен отправлять состояния нажатий клавиш:

```js
{
    code: 4,
    keycode: 1,
    press: true
}
```

Поле keycode может принимать следующие значения:
  - 0 - клавиша "влево"
  - 1 - клавиша "вправо"
  - 2 - клавиша активации бонуса

В зависимости от того нажата была клавиша или отпущена, поле press можно хранить: **true** - было произведено нажатие на клавишу, **false** - клавиша была отпущена.

После отправки, сервер рассылает данный пакет всем клиентам в текущей комнате в данном формате:
```js
{
    code: 5,
    player_id: 0,
    keycode: 1,
    press: true,
}
```
Где **playerId** - идентификатор игрока, который был передан ранее, при создании игры.
Клиенты при этом моделируют поведение всех змеек локально.

Во время игры сервер эмулирует всю механику у себя. С сервера приходят пакеты с изменениями змеек:
```js
{
    code: 6,
    snakeUpdates: [...],
}
```

Каждая змейка состоит из частей. Часть может быть двух видов: прямой отрезок или часть окружности. У каждой части есть свой идентификатор, уникальный в пределах змейки. От сервера приходит пакет с массивом изменений игрового поля **snakeUpdates**. Он может включать в себя следующие объекты:

##### Добавление/обновление части

```js
{
    action: 0,
    player_id: 399,
    partId: 5,
    partType: 0,
    pointFrom: {
        x: 1,
        y: 1
    },
    pointTo: {
        x: 2,
        y: 2
    },
    lineWidth: 3
}
```

##### Удаление части

```js
{
    action: 1,
    player_id: 399,
    part_id: 5
}
```

#### Бонусы
При появлении нового бонуса на карте, сервер рассылает следующий пакет:
```js
{
    code: 7,
    bonus: {
        type: 0,
        position: {
            x: 222,
            y: 333
        }
    }
}
```

Когда пользователь съедает бонус, сервер рассылает:
```js
{
    code: 8,
    player_id: 399,
    bonus: {
        type: 0,
        position: {
            x: 222,
            y: 333
        }
    }
}
```

#### Окончание раунда
Каждый игрок получает очки от 0 до 5 в зависимости от порядка проигрыша. Когда игрок умирает, сервер сообщает об этом игрокам:
```js
{
    code: 9,
    player_id: 399,
    rating: 1
}
```

При этом его змейка остается на карте до следующего раунда.

После окончания раунда (все игроки умерли) сервер может отправить два типа пакетов. Когда ожидается новый раунд:
```js
{
    code: 3,
    players: [
        {
            player_id: 399,
            username: "ivan333",
            rating: 3,
            color: "#abcdef",
            snake: {
                head: {
                    position: {
                        x: 567,
                        y: 124
                    },
                    speed: {
                        x: 8.66666666,
                        y: 4.33333333
                    }
                },
                parts: []
            }
        }
    ]
}
```

Когда количество очков достаточно для определения победителей:
```js
{
    code: 10,
    players: [
        {
            player_id: 399,
            username: "ivan333",
            rating: 3,
            color: "#abcdef",
        }
    ]
}
```

После этого происходит разрыв соединения по WebSocket'ам.

#### Управление комнатами

Для управления комнатами клиент, сразу после соединения по вебсокетам, выполняет отправку одного из следующих сообщений.

Для создания публичной комнаты и подключения к ней:
```js
{
    code: 19,
    private: false
}
```

Для создания приватной комнаты и подключения к ней:
```js
{
    code: 19,
    private: true
}
```

Для подключения к свободной публичной комнате (если свободной комнаты не будет найдено, будет создана новая комната):
```js
{
    code: 20,
    room: ''
}
```

Для подключения к определенной комнате:
```js
{
    code: 20,
    room: 'abcdef'
}
```

Для получения списка публичных комнат:
```js
{
    code: 21
}
```

После подключения к комнате возвращается ответ, содержащий ID комнаты.
